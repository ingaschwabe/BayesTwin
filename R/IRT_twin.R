<<<<<<< HEAD
#==========================================================
# IRT_twin.R
#
# Master function that calls subroutines for univariate
# analyses with one phenotype. 
#
# BayesTwin package
#==========================================================
IRT_twin = function(data_mz, data_dz, 
                    twin1_datacols_p, twin2_datacols_p,
                    twin1_datacols_cov = NA, twin2_datacols_cov = NA, 
                    decomp_model = "ACE",
                    irt_model = "1PL",
                    ge = FALSE,
                    n_iter = 10000, n_burnin = 8000,
                    n_chains = 1, fit_stats = FALSE, 
                    var_prior = "INV_GAMMA",
                    N_cov = 0, inits = NA, Nk = 0){
    #==========================================================
    # Error messages
    #==========================================================  
    if (irt_model == "GPCM" && Nk == 0){
        stop("When you want to analyse the data under the GPCM, please specify the number of categories of your 
             phenotypic data (Nk)!")
    }
    
    if (irt_model == "PCM" && Nk == 0){
        stop("When you want to analyse the data under the PCM, please specify the number of categories of your 
             phenotypic data (Nk)!")
    }
    
    if(length(twin1_datacols_p) == 1){
        stop("You need phenotypic data at item level to run the analysis! It is not possible to analyse sum scores")
    } 
    
    if(length(twin2_datacols_p) == 1){
        stop("You need phenotypic data at item level to run the analysis! It is not possible to analyse sum scores")
    } 
    
    #Test if it's possible to calculate fit statistics: 
    if( n_chains < 2 && fit_stats == TRUE){
        stop("If you want fit statisitcs, you need at least 2 Markov chains! Use the option n_chains to specify the number of chains")
    } 
    
    if(is.na(twin1_datacols_cov) == FALSE && is.na(twin2_datacols_cov) == TRUE || 
       is.na(twin1_datacols_cov) == TRUE && is.na(twin2_datacols_cov) == FALSE){
        stop("It looks like you have specified covariates for the first twin, but not for the second twin of a family. 
             This is not possible! When using covariates, these should be measured in both first and second twin of each family. 
             Please use twin1_datacols_cov to specifiy the columns of the first twin and twin2_datacols_cov 
             for the second twin of each family.")
    }
    
    #Calculate number of MZ and DZ twins: 
    n_mz = nrow(data_mz)
    n_dz = nrow(data_dz)
    
    #Choose initial values if not specified otherwise by user: 
    if (is.na(inits) && ge == FALSE){
        if (decomp_model == "ACE"){
            inits = list(tau_a = 2, tau_c = 3, tau_e = 5)
        } else if (decomp_model == "ADE"){
            inits = list(tau_a = 2, tau_d = 3, tau_e = 5)
        } else {
            inits = list(tau_a = 2, tau_e = 2)
        }
        
    } 
    
    if (is.na(inits) && ge == TRUE){
        if (decomp_model == "ACE"){
            inits = list(tau_a = 2, tau_c = 3, beta0 = log(0.2), beta1 = 0)
        } else if (decomp_model == "ADE"){
            inits = list(tau_a = 2, tau_d = 3, beta0 = log(0.2), beta1 = 0)
        } else {
            inits = list(tau_a = 2, beta0 = log(0.2), beta1 = 0)
        }
    } 
    
    #==========================================================
    # Covariates
    #==========================================================  
    #Test if covariates are used:
    covariates = NA
    
    #Option I: Use covaritaes without missing value imputation: 
    if (is.na(twin1_datacols_cov) == FALSE){
        
        ### erst missings kijken want moet op hele data set!!!!!
        without_missings = na.omit(data_mz[,c(twin1_datacols_cov, twin2_datacols_cov)])
        
        cov_data_mz_twin1 = data_mz[,twin1_datacols_cov]
        
        #Use only data with complete cases, meaning that cases with missing values
        #on covariate data will be ommited from the data anlysis, even if that means
        #that we do not use all known phenotypic values.
        
        #Which cases have missing values on covariate data: 
        
        without_missings = na.omit(data_mz[,c(twin1_datacols_cov, twin2_datacols_cov)])
        data_mz = data_mz[without_missings[,ncol(data_mz)],] 
        
        data_dz[1:n_mz, ncol(data_dz)] = 1:n_dz         
        without_missings = na.omit(data_dz[,c(twin1_datacols_cov, twin2_datacols_cov)])
        data_dz = data_dz[without_missings[,ncol(data_dz)],] 
        
        #Select only covariate data on basis of new dataset without missings: 
        X_mz_twin1 = data_mz[,twin1_datacols_cov]
        X_mz_twin2 = data_mz[,twin2_datacols_cov]
        X_dz_twin1 = data_dz[,twin1_datacols_cov]
        X_dz_twin2 = data_dz[,twin2_datacols_cov]
        covariates = TRUE
        
        #We have to know which covariates are dichotomous and which continous: 
        is.binary = function(x){
            length(unique(x)) <= 3 #allow for values 0,1 and NA. 
        }
        
        dich = NA; cont = NA
        
        #Apply on all covariate data: (assuming that the same covariates cannot 
        #be dichotomous for twin 1 and continous for twin 2 + assuming that 
        #the same covariates are dichotomous for MZ and DZ twins
        if(length(twin1_datacols_cov) > 1){
            dich_cov = which(apply(X_mz_twin1, 2, is.binary) == TRUE)
            cont_cov = which(apply(X_mz_twin1, 2, is.binary) == FALSE)
            if(length(dich_cov) >= 1){
                dich = TRUE
            } else{
                dich = FALSE
            }
            
            if(length(cont_cov) >= 1){
                cont = TRUE
            } else {
                cont = FALSE
            }
            
        } else {
            dich_cov = is.binary(X_mz_twin1)
            if(dich_cov == FALSE){
                dich = FALSE; cont = TRUE 
                cont_cov = twin1_datacols_cov
            } else {
                dich = TRUE
                dich_cov = twin1_datacols_cov
            }
        }
        
    } else {covariates = FALSE}
    
    
    #Make sure that first columns are only twin 1, next the twin 2 columns
    data_mz = data_mz[,c(twin1_datacols_p, twin2_datacols_p)]
    data_dz = data_dz[,c(twin1_datacols_p, twin2_datacols_p)]
    
    #==========================================================
    #==========================================================
    # Subroutines for AE model
    #==========================================================
    #Option for IRT model (1pl/2pl or (G)PCM) passed to function
    #with irt_model object and option fo genotype by environment
    #interaction by ge = FALSE/TRUE
    
    #I. With covariates: 
    if(covariates == TRUE && decomp_model == "AE"){
        output = irt_ae_cov(data_mz = data_mz, data_dz = data_dz, 
                            X_mz_twin1 = X_mz_twin1, 
                            X_mz_twin2 = X_mz_twin2, 
                            X_dz_twin1 = X_dz_twin1,
                            X_dz_twin2 = X_dz_twin2,
                            n_burnin = n_burnin, n_iter = n_iter, 
                            ge = ge, irt_model = irt_model, 
                            N_cov = N_cov, var_prior = var_prior,
                            n_chains = n_chains, fit_stats = fit_stats,
                            inits = inits, Nk = Nk)
    }
    
    #II. Without covariates: 
    if(covariates == FALSE && decomp_model == "AE"){
        output = irt_ae(data_mz = data_mz, data_dz = data_dz, 
                        n_burnin = n_burnin, n_iter = n_iter,
                        ge = ge, irt_model = irt_model,
                        var_prior = var_prior,
                        n_chains = n_chains, fit_stats = fit_stats,
                        inits = inits, Nk = Nk)              
    } 
    
    #==========================================================
    # Subroutines for ACE model
    #==========================================================
    #Option for IRT model (1pl/2pl or (G)PCM) passed to function
    #with irt_model object and option fo genotype by environment
    #interaction by ge = FALSE/TRUE
    
    #I. With covariates: 
    if(covariates == TRUE && decomp_model == "ACE"){
        output = irt_ace_cov(data_mz = data_mz, data_dz = data_dz, 
                             X_mz_twin1 = X_mz_twin1, 
                             X_mz_twin2 = X_mz_twin2, 
                             X_dz_twin1 = X_dz_twin1,
                             X_dz_twin2 = X_dz_twin2,
                             n_burnin = n_burnin, n_iter = n_iter, 
                             ge = ge, irt_model = irt_model, 
                             N_cov = N_cov,
                             var_prior = var_prior,
                             n_chains = n_chains, fit_stats = fit_stats,
                             inits = inits, Nk = Nk)
    }
    
    #II. Without covariates: 
    if(covariates == FALSE && decomp_model == "ACE"){
        output = irt_ace(data_mz = data_mz, data_dz = data_dz, 
                         n_burnin = n_burnin, n_iter = n_iter,
                         ge = ge, irt_model = irt_model,
                         var_prior = var_prior,
                         n_chains = n_chains, fit_stats = fit_stats,
                         inits = inits, Nk = Nk)              
    } 
    
    
    #==========================================================
    #==========================================================
    # Subroutines for ADE model
    #==========================================================
    #Option for IRT model (1pl/2pl or (G)PCM) passed to function
    #with irt_model object and option fo genotype by environment
    #interaction by ge = FALSE/TRUE
    
    #I. With covariates: 
    if(covariates == TRUE && decomp_model == "ADE"){
        output = irt_ade_cov(data_mz = data_mz, data_dz = data_dz, 
                             X_mz_twin1 = X_mz_twin1, 
                             X_mz_twin2 = X_mz_twin2, 
                             X_dz_twin1 = X_dz_twin1,
                             X_dz_twin2 = X_dz_twin2,
                             n_burnin = n_burnin, n_iter = n_iter, 
                             ge = ge, irt_model = irt_model, 
                             N_cov = N_cov, var_prior = var_prior,
                             n_chains = n_chains, fit_stats = fit_stats,
                             inits = inits, Nk = Nk)
    }
    
    #II. Without covariates: 
    if(covariates == FALSE && decomp_model == "ADE"){
        output = irt_ade(data_mz = data_mz, data_dz = data_dz, 
                         n_burnin = n_burnin, n_iter = n_iter,
                         ge = ge, irt_model = irt_model,
                         n_chains = n_chains, fit_stats = fit_stats, 
                         inits = inits, Nk = Nk)              
    } 

    #==========================================================
    # Output
    #==========================================================
    if(ge == TRUE){
        cat("\n Analysis completed.") 
        cat("\n After a burn-in period of", n_burnin, "iterations,")
        cat("the characterisation of the posterior distribution for \n", 
            "the model parameters was based on an additional", n_iter, "iterations from", n_chains, "Markov chain(s).")
        cat("\n The analysis was run using an", decomp_model, "model", "with an integrated", irt_model, "IRT model.")
        cat("\n The model was analysed with gene-environment interaction effect.\n")
        
    } else {
        cat("\n Analysis completed.") 
        cat("\n After a burn-in period of", n_burnin, "iterations,")
        cat("the characterisation of the posterior distribution for \n", 
            "the model parameters was based on an additional", n_iter, "iterations from", n_chains, "Markov chain(s).")
        cat("\n The analysis was run using an", decomp_model, "model", "with an integrated", irt_model, "IRT model.")
        cat("\n The model was analysed without gene-environment interaction effect.\n")
    }
    cat("=================================================================")
    
    #Remind user of convergence-issue
    cat("\n WARNING! \n")
    cat("It is important to check that the MCMC algorithm has converged to the posterior distribution! \n")
    cat("To check convergence, you can use the posterior samples and the plot function with type = 'Sampling plot'. \n",
        "For example, call ACE_model$samples_var_a to obtain the samples for VAR(A) when the output of the analysis was saved in the object ACE_model. \n",
        "You can then use plot(ACE_model$samples_vara_a, type = 'Sampling plot') to check the convergence of the VAR(A) parameter.\n")
    cat("=================================================================")
    cat("\n For posterior means and standard deviations of all variance components, see below or use the summary function \n",
        "For example: summary(ACE_model$results) when the Ouptut of the analysis was saved in the object ACE_model).\n")
    cat("=================================================================")
    cat("\n")
    
    #Print results on the fly:
    print(output$results)
    
    #Return output, but do not print it
    output
=======
#==========================================================
# twinUniv.R
# Master function that calls subroutines for univariate
# analyses with one phenotype. 
# BayesTwin package
#==========================================================
#setwd("C:/Users/schwabei/Dropbox/International student performance_IngaStephanie/R/BayesTwin3/R")
#setwd("/Users/stephanievandenberg/Dropbox/International student performance_IngaStephanie/R/BayesTwin3/R")
#setwd("C:/Users/inga/Dropbox/International student performance_IngaStephanie/R/BayesTwin3/R")
#setwd("/Users/inga/Dropbox/International student performance_IngaStephanie/R/BayesTwin3/R")

IRT_twin = function(data_mz, data_dz, 
                    twin1_datacols_p, twin2_datacols_p,
                    twin1_datacols_cov = NA, twin2_datacols_cov = NA, #####KOMT LATER
                    decomp_model = "ACE",
                    irt_model = "1PL",
                    ge = FALSE,
                    n_iter = 10000, n_burnin = 5000,
                    n_chains = 1, fit_stats = FALSE, 
                    var_prior = "INV_GAMMA"){
    #Load HPD function: 
    source("HPD.R")                                                         
    
    #Calculate number of MZ and DZ twins: 
    n_mz = nrow(data_mz)
    n_dz = nrow(data_dz)
    
    #Make sure that first columns are only twin 1, next the twin 2 columns
    data_mz = data_mz[,c(twin1_datacols_p, twin2_datacols_p)]
    data_dz = data_dz[,c(twin1_datacols_p, twin2_datacols_p)]
    
    #Test if its item data: 
    if(length(twin1_datacols_p) == 1){
        stop("You need phenotypic data at item level to run the analysis!")
    } 
    
    #Test if it's possible to calculate fit statistics: 
    if( n_chains < 2 && fit_stats == TRUE){
        stop("If you want fit statisitcs, you need at least 2 Markov chains! Use the option n_chains to specify the number of chains")
    } 
    
    
    ########## Covariates #############################################
    #Test if covariates are used:
    covariates = NA
    
    #Option I: Use covaritaes without missing value imputation: 
    if (is.na(twin1_datacols_cov) == FALSE && cov_imputation == TRUE){
        X_mz_twin1 = data_mz[,twin1_datacols_cov]
        X_mz_twin2 = data_mz[,twin2_datacols_cov]
        X_dz_twin1 = data_dz[,twin1_datacols_cov]
        X_dz_twin2 = data_dz[,twin2_datacols_cov]
        covariates = TRUE
        
        #We have to know which covariates are dichotomous and which continous: 
        is.binary = function(x){
            length(unique(x)) <= 3 #allow for values 0,1 and NA. 
        }
        
        dich = NA; cont = NA
        
        #Apply on all covariate data: (assuming that the same covariates cannot 
        #be dichotomous for twin 1 and continous for twin 2 + assuming that 
        #the same covaraites are dichotomous for MZ and DZ twins
        if(length(twin1_datacols_cov) > 1){
            dich_cov = which(apply(X_mz_twin1, 2, is.binary) == TRUE)
            cont_cov = which(apply(X_mz_twin1, 2, is.binary) == FALSE)
            if(length(dich_cov) >= 1){
                dich = TRUE
            } else{
                dich = FALSE
            }
            
            if(length(cont_cov) >= 1){
                cont = TRUE
            } else {
                cont = FALSE
            }
                
        } else {
            dich_cov = is.binary(X_mz_twin1)
            if(dich_cov == FALSE){
                dich = FALSE; cont = TRUE 
                cont_cov = twin1_datacols_cov
            } else {
                dich = TRUE
                dich_cov = twin1_datacols_cov
            }
        }
                        
    #Option II: Use covariates with missing value imputation:
    } else if (is.na(twin1_datacols_cov) == FALSE && cov_imputation == FALSE){
        
        #Use only data with complete cases, meaning that cases with missing values
        #on covariate data will be ommited from the data anlysis, even if that means
        #that we do not use all known phenotypic values.
        
        #Which cases have missing values on covariate data: 
        data_mz[1:n_mz, ncol(data_mz)] = 1:n_mz            
        without_missings = na.omit(data_mz[,c(twin1_datacols_cov, twin2_datacols_cov)])
        data_mz = data_mz[without_missings[,ncol(data_mz)],] 
        
        data_dz[1:n_mz, ncol(data_dz)] = 1:n_dz         
        without_missings = na.omit(data_dz[,c(twin1_datacols_cov, twin2_datacols_cov)])
        data_dz = data_dz[without_missings[,ncol(data_dz)],] 
        
        #Select only covariate data on basis of new dataset without missings: 
        X_mz_twin1 = data_mz[,twin1_datacols_cov]
        X_mz_twin2 = data_mz[,twin2_datacols_cov]
        X_dz_twin1 = data_dz[,twin1_datacols_cov]
        X_dz_twin2 = data_dz[,twin2_datacols_cov]
        covariates = TRUE
    
    } else {covariates = FALSE}
    
    #==========================================================
    #==========================================================
    # Subroutines for AE model
    #==========================================================
    #Option for IRT model (1pl/2pl or (G)PCM) passed to function
    #with irt_model object and option fo genotype by environment
    #interaction by ge = FALSE/TRUE
    
    #I. With covariates: 
    if(covariates == TRUE && decomp_model == "AE"){
        source("irt_ae_cov.R")
        output = irt_ae_cov(data_mz = data_mz, data_dz = data_dz, 
                            n_burnin = n_burnin, n_iter = n_iter, 
                            ge = ge, irt_model = irt_model, 
                            N_cov = N_cov, var_prior = var_prior,
                            n_chains = n_chains, fit_stats = fit_stats)
    }
    
    #II. Without covariates: 
    if(covariates == FALSE && decomp_model == "AE"){
        source("irt_ae.R")
        output = irt_ae(data_mz = data_mz, data_dz = data_dz, 
                        n_burnin = n_burnin, n_iter = n_iter,
                        ge = ge, irt_model = irt_model,
                        var_prior = var_prior,
                        n_chains = n_chains, fit_stats = fit_stats)              
    } 
    
    #==========================================================
    # Subroutines for ACE model
    #==========================================================
    #Option for IRT model (1pl/2pl or (G)PCM) passed to function
    #with irt_model object and option fo genotype by environment
    #interaction by ge = FALSE/TRUE
    
    #I. With covariates: 
    if(covariates == TRUE && decomp_model == "ACE"){
        source("irt_ace_cov.R")
        output = irt_ace_cov(data_mz = data_mz, data_dz = data_dz, 
                            n_burnin = n_burnin, n_iter = n_iter, 
                            ge = ge, irt_model = irt_model, 
                            N_cov = N_cov,
                            var_prior = var_prior,
                            n_chains = n_chains, fit_stats = fit_stats)
    }
    
    #II. Without covariates: 
    if(covariates == FALSE && decomp_model == "ACE"){
        source("irt_ace.R")
        output = irt_ace(data_mz = data_mz, data_dz = data_dz, 
                        n_burnin = n_burnin, n_iter = n_iter,
                        ge = ge, irt_model = irt_model,
                        var_prior = var_prior,
                        n_chains = n_chains, fit_stats = fit_stats)              
    } 
    

    #==========================================================
    #==========================================================
    # Subroutines for ADE model
    #==========================================================
    #Option for IRT model (1pl/2pl or (G)PCM) passed to function
    #with irt_model object and option fo genotype by environment
    #interaction by ge = FALSE/TRUE
    
    #I. With covariates: 
    if(covariates == TRUE && decomp_model == "ADE"){
        source("irt_ade_cov.R")
        output = irt_ade_cov(data_mz = data_mz, data_dz = data_dz, 
                             n_burnin = n_burnin, n_iter = n_iter, 
                             ge = ge, irt_model = irt_model, 
                             N_cov = N_cov, var_prior = var_prior,
                             n_chains = n_chains, fit_stats = fit_stats)
    }
    
    #II. Without covariates: 
    if(covariates == FALSE && decomp_model == "ADE"){
        source("irt_ade.R")
        output = irt_ade(data_mz = data_mz, data_dz = data_dz, 
                         n_burnin = n_burnin, n_iter = n_iter,
                         ge = ge, irt_model = irt_model,
                         n_chains = n_chains, fit_stats = fit_stats)              
    } 

    
    #==========================================================
    # Output
    #==========================================================
    source("plot.bayestwin.R") #load method for generic function (not necessary when library is finished) 
    
    #Remind user of convergence-issue
    cat("\n Here give some advice over convergence")
    cat("\n Here explain how to get results etc")
    
    #Print results on the fly: 
    cat("\n") 
    print(output$results) #table that is made in subroutine (always give same name!)
    return(output) 
>>>>>>> 580e32ad986f43fb99925137796f29266474c179
}